package com.bubblecraft.bubblerune;

import org.mockbukkit.mockbukkit.MockBukkit;
import org.mockbukkit.mockbukkit.ServerMock;
import org.mockbukkit.mockbukkit.entity.PlayerMock;
import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.event.block.Action;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.inventory.EquipmentSlot;
import org.bukkit.inventory.ItemFlag;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class RuneExploitRegressionTest {
    private ServerMock server;
    private BubbleRunePlugin plugin;

    @BeforeEach
    void setUp() {
        server = MockBukkit.mock();
        plugin = MockBukkit.load(BubbleRunePlugin.class);

        // Keep tests deterministic and vanilla-only.
        plugin.getConfig().set("runePreview.enabled", true);
        plugin.getConfig().set("tiers.common.enchants", List.of("unbreaking"));
        plugin.getConfig().set("tiers.common.minLevel", 1);
        plugin.getConfig().set("tiers.common.maxLevel", 1);

        plugin.getRuneService().reload();
    }

    @AfterEach
    void tearDown() {
        MockBukkit.unmock();
    }

    @Test
    void renamedKeyWithHiddenUnbreaking_doesNotTriggerRuneReveal() {
        PlayerMock player = server.addPlayer();

        ItemStack key = new ItemStack(Material.TRIPWIRE_HOOK);
        ItemMeta meta = key.getItemMeta();
        assertNotNull(meta);
        meta.setDisplayName("Trial Key");
        meta.addEnchant(Enchantment.UNBREAKING, 1, true);
        meta.addItemFlags(ItemFlag.HIDE_ENCHANTS);
        meta.setLore(List.of("Some custom lore", "More lore"));
        key.setItemMeta(meta);

        int beforeAmount = key.getAmount();
        int beforeBooks = count(player, Material.ENCHANTED_BOOK);

        RuneItemListener listener = new RuneItemListener(plugin, plugin.getRuneService());
        PlayerInteractEvent event = new PlayerInteractEvent(player, Action.RIGHT_CLICK_AIR, key, null, null, EquipmentSlot.HAND);
        listener.onRightClickRune(event);

        assertEquals(beforeAmount, key.getAmount(), "Non-rune items must not be consumed by BubbleRune");
        assertEquals(beforeBooks, count(player, Material.ENCHANTED_BOOK), "Should not grant any enchanted book");
    }

    @Test
    void genuineRune_triggersRevealAndConsumesOne() {
        PlayerMock player = server.addPlayer();

        ItemStack rune = plugin.getRuneService().createRuneItem(RuneTier.COMMON);
        assertNotNull(rune);
        assertTrue(RuneItemData.isRune(rune, plugin), "Created runes must be PDC-marked");

        player.getInventory().setItemInMainHand(rune);
        int beforeRuneAmount = rune.getAmount();
        int beforeBooks = count(player, Material.ENCHANTED_BOOK);

        RuneItemListener listener = new RuneItemListener(plugin, plugin.getRuneService());
        PlayerInteractEvent event = new PlayerInteractEvent(player, Action.RIGHT_CLICK_AIR, rune, null, null, EquipmentSlot.HAND);
        listener.onRightClickRune(event);

        assertTrue(event.isCancelled(), "Rune right click should be handled and cancelled");
        assertEquals(beforeRuneAmount - 1, rune.getAmount(), "Rune should be consumed by 1");
        assertTrue(count(player, Material.ENCHANTED_BOOK) > beforeBooks, "Should grant at least one enchanted book");
    }

    @Test
    void spoofedPreviewLoreMarker_doesNotTriggerPreviewReveal() {
        PlayerMock player = server.addPlayer();

        ItemStack spoofed = new ItemStack(Material.PAPER);
        ItemMeta meta = spoofed.getItemMeta();
        assertNotNull(meta);
        meta.setDisplayName("? COMMON Rune ?");
        meta.setLore(List.of("Preview rune!", "Enchantment ID: veinminer"));
        spoofed.setItemMeta(meta);

        int beforeAmount = spoofed.getAmount();
        int beforeBooks = count(player, Material.ENCHANTED_BOOK);

        RuneItemListener listener = new RuneItemListener(plugin, plugin.getRuneService());
        PlayerInteractEvent event = new PlayerInteractEvent(player, Action.RIGHT_CLICK_AIR, spoofed, null, null, EquipmentSlot.HAND);
        listener.onRightClickRune(event);

        assertEquals(beforeAmount, spoofed.getAmount(), "Spoofed preview items must not be consumed by BubbleRune");
        assertEquals(beforeBooks, count(player, Material.ENCHANTED_BOOK), "Should not grant any enchanted book");
    }

    @Test
    void genuinePreviewRune_triggersRevealAndConsumesOne() {
        PlayerMock player = server.addPlayer();

        RunePreviewService previewService = new RunePreviewService(plugin);
        ItemStack previewRune = previewService.createPreviewRune(RuneTier.COMMON, "unbreaking");
        assertNotNull(previewRune);
        assertTrue(previewService.isPreviewRune(previewRune));

        int beforeBooks = count(player, Material.ENCHANTED_BOOK);

        RuneItemListener listener = new RuneItemListener(plugin, plugin.getRuneService());
        PlayerInteractEvent event = new PlayerInteractEvent(player, Action.RIGHT_CLICK_AIR, previewRune, null, null, EquipmentSlot.HAND);
        listener.onRightClickRune(event);

        assertTrue(event.isCancelled(), "Preview rune right click should be handled and cancelled");
        assertEquals(0, previewRune.getAmount(), "Preview rune should be consumed by 1");
        assertTrue(count(player, Material.ENCHANTED_BOOK) > beforeBooks, "Should grant at least one enchanted book");
    }

    private static int count(PlayerMock player, Material type) {
        int total = 0;
        for (ItemStack item : player.getInventory().getContents()) {
            if (item != null && item.getType() == type) {
                total += item.getAmount();
            }
        }
        return total;
    }
}
